#include <REGX52.H>

/*
	波特率计算，以本程序为例：
	已设置定时器1模式为8位自动重装模式，每计数到256溢出一次
	定时器1初值与重装值均为0xF4，转化为十进制为244
	定时器1每溢出一次，向接收/发送控制器发出一次脉冲
	256-244=12，即每计12次数溢出一次
	
	定时器晶振频率为11.0592MHZ，即每秒钟振荡11059200次
	12分频后每秒钟发送脉冲11059200/12=921600次
	所以定时器每一次计数时间为1000000（微秒）/921600=1.085微秒
	即每溢出一次（计数12次）的时间为1000000/921600*12=13.02微秒
	
	则可算出定时器1的溢出率为1秒/13.02微秒=76800赫兹=76.8KHZ=0.0768MHZ
	同时已配置波特率倍速位SMOD=1
	则最后发送到接收/发送控制器的频率只需再进行一次16分频
	因此最后的实际频率也即波特率为76800赫兹/16=4800赫兹
	
	总结：
	串行通信模式1的波特率=2^SMOD/32*(定时器/计数器1溢出率)
	当单片机工作在12T模式时，定时器1的溢出率 = SYSclk/12/(256 - TH1)
	当单片机工作在6T模式时，定时器1的溢出率 = SYSclk/6/(256 - TH1)
*/

/**
  * @brief	串口初始化，4800bps@11.0592MHz
  * @param	无
  * @retval	无
  */
void UART_Init(){	//初始化串口
	
	SCON = 0x50;	//配置串行口控制寄存器，注意应将REN位置1
	PCON |= 0x80;	//使能波特率倍速位SMOD
	
	//设置定时器1模式为8位自动重装模式
	/*
	就是十六位记的数多，但每次都需要自己写的代码赋初值，浪费时间。
	双八位就是将十六位分开，一个计数，另一个存放初值，
	每次计数完成后AR会自动将值赋给CNT，不用代码处理，比较快，
	但只有八位所以记的数少了。
	*/
	TMOD &= 0x0F;		
	TMOD |= 0x20;	//设置定时器1模式		
	
	TL1 = 0xF4;		//设定定时初值
	TH1 = 0xF4;		//设定定时器重装值
	
	//TF1 = 0;		//清除TF1标志
	TR1 = 1;		//定时器1开始计时
	ET1 = 0;		//禁止定时器1中断，只作为波特率发生器
	//允许总中断
	EA = 1;
	//允许串口中断
	ES = 1;
	//配置定时器1中断优先级
	//只设置了IP寄存器，配置T1中断为低优先级
	//PT1 = 0;
}

/**
  * @brief	串口发送一个字节数据
  * @param	Byte 要发送的一个字节数据
  * @retval	无
  */
void UART_SendByte(unsigned char byte){
	//给串口缓存写入数据
	SBUF = byte;
	//向串口缓存写入数据后，单片机会自动通过串口向外发送数据
	//当串行发送数据第8位结束时，TI自动置1
	while(TI == 0);
	//手动将TI置0
	TI = 0;
}

/*	串口中断函数
void UARTInterrupt() interrupt 4{
	if(TI == 1){
		LCD_ShowNum(2,6,key,2);		//键值发送完成后在LCD上显示发送的键值
		//P2 = 0xF0;
	}else if(RI == 1){
		//P2 = ~SBUF;
		LCD_ShowHexNum(1,6,SBUF,2);	//在LCD上显示接收的16进制数
		UART_SendByte(SBUF);		//将接收的16进制数再发送给上位机
		//SBUF = SBUF;
		//while(TI == 0);
		//TI = 0;
		RI = 0;
	}
}
*/

/*
void UartInit(void)		//4800bps@11.0592MHz
{
	PCON |= 0x80;		//使能波特率倍速位SMOD
	SCON = 0x50;		//8位数据,可变波特率
	AUXR &= 0xBF;		//定时器1时钟为Fosc/12,即12T
	AUXR &= 0xFE;		//串口1选择定时器1为波特率发生器
	TMOD &= 0x0F;		//清除定时器1模式位
	TMOD |= 0x20;		//设定定时器1为8位自动重装方式
	TL1 = 0xF4;		//设定定时初值
	TH1 = 0xF4;		//设定定时器重装值
	ET1 = 0;		//禁止定时器1中断
	TR1 = 1;		//启动定时器1
}
*/	

/*
* AUXR.0：为1时串口波特率发生器为定时器2，否则默认定时器1
* AUXR.1：为1可使用内部扩展RAM
* AUXR.2：（定时器2速度控制位）为1则CPU时钟不分频（1T），否则12分频
* AUXR.3：（定时器0控制位）为1用作定时器，为0用作计数器
* AUXR.4：为1定时器2开始计数，为0停止
* AUXR.5：为1则串口1模式0通讯速度为2分频，否则12分频
* AUXR.6：为1则定时器1不分频，否则12分频
* AUXR.7：为1则定时器0不分频，否则12分频
*/
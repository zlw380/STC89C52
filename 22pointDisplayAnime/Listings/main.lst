C51 COMPILER V9.54   MAIN                                                                  05/13/2023 17:44:58 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: F:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "Delay.h"
   3          #include "MatrixLED.h"
   4          
   5          //添加code关键字使数组数据被存放在外存中，不占用宝贵的内存空间
   6          //但是在程序运行时，外存中的数据只能读取，不能写入
   7          unsigned char code animation[]={
   8                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
   9                  0x24,0x24,0xA4,0xAF,0xA8,0x34,0x20,0x01,0xE2,0xBC,0xA0,0xBF,0xE1,0x01,0x02,0x00,
  10                  0x00,0x21,0x21,0xB2,0xAC,0xB2,0x21,0x21,0x00,0x7E,0x00,0x01,0xFF,0x00,0x04,0x26,
  11                  0x46,0xDA,0x56,0x5A,0x57,0x5A,0x5E,0x04,0x29,0x3E,0xA8,0xAF,0xA8,0x3F,0x29,0x0B,
  12                  0x00,0x00,0x2C,0x34,0xE4,0xA4,0xA4,0xEC,0xED,0xA5,0xA5,0xFE,0x24,0x24,0x00,0x00,
  13                  0x10,0x54,0x56,0x76,0xD5,0xDF,0xD4,0x76,0x56,0x54,0x10,0x00,0x40,0x50,0x50,0xF0,
  14                  0x50,0x5F,0x50,0xF0,0x52,0x5E,0x40,0x00,0x00,0x08,0x30,0x00,0xFF,0x00,0x30,0x08,
  15                  0x29,0x2A,0x2C,0xF8,0x2C,0x3A,0x09,0x09,0x00,0x00,0x08,0x08,0x3A,0x4A,0x48,0x49,
  16                  0x7F,0x48,0x48,0xCA,0x0A,0x08,
  17                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  18          };
  19          
  20          /*      
  21                  0x41,0x81,0xFF,0x01,0x01,0x00,0x00,0x41,0x81,0xFF,0x01,0x01,0x00,0x00,0xF8,0x08,
  22                  0x08,0xFF,0x08,0x00,0x00,0xF1,0x91,0x91,0x91,0x9F,0x00,0x00,0x41,0x81,0xFF,0x01,
  23                  0x01,0x00,0x00,0xF8,0x08,0x08,0xFF,0x08,0x00,0x00,0xFF,0x18,0x24,0x42,0x81,0x00,
  24                  0x00,0x7E,0x81,0x81,0x81,0x7E,0x00,0x00,0x00,0x81,0xFF,0x81,0x00,0x00,0x00,0x71,
  25                  0x91,0x99,0x89,0x8E,0x00,0x00,0xFF,0x10,0x10,0x10,0xFF,0x00,0x00,0x00,0x81,0xFF,
  26                  0x81,
  27          
  28                  0x24,0x24,0xA4,0xAF,0xA8,0x34,0x20,0x01,0xE2,0xBC,0xA0,0xBF,0xE1,0x01,0x02,0x00,
  29                  0x00,0x21,0x21,0xB2,0xAC,0xB2,0x21,0x21,0x00,0x7E,0x00,0x01,0xFF,0x00,0x04,0x26,
  30                  0x46,0xDA,0x56,0x5A,0x57,0x5A,0x5E,0x04,0x29,0x3E,0xA8,0xAF,0xA8,0x3F,0x29,0x0B,
  31                  0x00,0x00,0x2C,0x34,0xE4,0xA4,0xA4,0xEC,0xED,0xA5,0xA5,0xFE,0x24,0x24,0x00,0x00,
  32                  0x10,0x54,0x56,0x76,0xD5,0xDF,0xD4,0x76,0x56,0x54,0x10,0x00,0x40,0x50,0x50,0xF0,
  33                  0x50,0x5F,0x50,0xF0,0x52,0x5E,0x40,0x00,0x00,0x08,0x30,0x00,0xFF,0x00,0x30,0x08,
  34                  0x29,0x2A,0x2C,0xF8,0x2C,0x3A,0x09,0x09,0x00,0x00,0x08,0x08,0x3A,0x4A,0x48,0x49,
  35                  0x7F,0x48,0x48,0xCA,0x0A,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  36                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  37                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  38          */
  39          
  40          unsigned char code frame[]={
  41                  //0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  42                  0x00,0xFF,0x60,0x10,0x08,0x06,0xFF,0x00,
  43                  0x00,0x3F,0x48,0x88,0x88,0x48,0x3F,0x00,
  44                  0x00,0xFF,0x10,0x10,0x10,0x10,0xFF,0x00,
  45                  0x00,0x00,0x81,0xFF,0xFF,0x81,0x00,0x00,
  46                  0x00,0xFF,0x81,0x81,0x81,0x42,0x3C,0x00,
  47                  0x00,0x3F,0x48,0x88,0x88,0x48,0x3F,0x00,
  48                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  49          };
  50          
  51          void main(){
  52   1              //初始偏移量为0
  53   1              int i,offset=0,count=0;
  54   1              matrixLED_Init();
C51 COMPILER V9.54   MAIN                                                                  05/13/2023 17:44:58 PAGE 2   

  55   1              //P0 = 0x00;
  56   1              //_74HC595_WriteByte(0x0F);
  57   1              
  58   1              while(1){
  59   2                      //i从0-7循环，显示8列段选信号
  60   2                      //偏移量的自增需要放到位选循环外面
  61   2                      //这里相当于循环嵌套，内层负责不断刷新每一列的信息，外层负责每隔一定时
             -间增加偏移量
  62   2                      for(i = 0;i < 8;i++){
  63   3                              matrixLED_ShowColumn(i,animation[i+offset]);    //滚动
  64   3                              //matrixLED_ShowColumn(i,frame[i+offset]);              //逐帧
  65   3                      }
  66   2                      count++;
  67   2                      if(count>8){
  68   3                              count = 0;
  69   3                              offset++;
  70   3                              //offset += 8;
  71   3                              if(offset >= sizeof(animation)-8){
  72   4                              //if(offset >= sizeof(frame)-8){
  73   4                                      offset = 0;
  74   4                              }
  75   3                      }
  76   2                      
  77   2                      
  78   2                      /*
  79   2                      可以正常显示，但是由于消影+延时操作，屏幕会不断闪烁
  80   2                      因为每一帧位清零/段清零后延时100毫秒，相当于屏幕熄灭100毫秒，然后再显示
             -一帧数据
  81   2                      如果不设置延时，满屏就会全都是亮点
  82   2                      //sizeof得出数组长度后要减去一个点阵屏的宽度，不然后面就会溢出显示乱码
  83   2                      for(i = 0;i < sizeof(animation)-8;i++){
  84   2                              matrixLED_ShowColumn(0,animation[i]);
  85   2                              matrixLED_ShowColumn(1,animation[i+1]);
  86   2                              matrixLED_ShowColumn(2,animation[i+2]);
  87   2                              matrixLED_ShowColumn(3,animation[i+3]);
  88   2                              matrixLED_ShowColumn(4,animation[i+4]);
  89   2                              matrixLED_ShowColumn(5,animation[i+5]);
  90   2                              matrixLED_ShowColumn(6,animation[i+6]);
  91   2                              matrixLED_ShowColumn(7,animation[i+7]);
  92   2                              setTimeout(100);
  93   2                      }
  94   2                      */
  95   2                      /*
  96   2                      无法正常显示，代码作废
  97   2                      for(i = 0;i < 8;i++){
  98   2                              matrixLED_ShowColumn(0-i,0x38);
  99   2                              matrixLED_ShowColumn(1-i,0x44);
 100   2                              matrixLED_ShowColumn(2-i,0x42);
 101   2                              matrixLED_ShowColumn(3-i,0x21);
 102   2                              matrixLED_ShowColumn(4-i,0x21);
 103   2                              matrixLED_ShowColumn(5-i,0x42);
 104   2                              matrixLED_ShowColumn(6-i,0x44);
 105   2                              matrixLED_ShowColumn(7-i,0x38);
 106   2                              setTimeout(500);
 107   2                      }
 108   2                      */
 109   2              }
 110   1      }
 111          
 112          /*
 113          个人理解可位寻址与不可位寻址：
 114          使用sbit关键字声明可位寻址特殊寄存器中的特殊位时
C51 COMPILER V9.54   MAIN                                                                  05/13/2023 17:44:58 PAGE 3   

 115          如 sbit P0_1 = 0x81; 或 sbit P0_1 = P0^1; 即声明P0寄存器的第1位
 116          编译器会自动根据该可位寻址特殊寄存器的首地址加上表示地址单元中第几位的
             -字进行位寻址
 117          
 118          而在单片机系统中，操作任意寄存器或者某一位的数据时，必须给出其物理地址
 119          即就算是声明后的地址单元，最后也需要转化为物理地址（0xXX）作为指令中的操
             -作数
 120          这样由于每个SFR都有八位，就没有足够的物理地址来表示每个的SFR中的每一位了
 121          只能在每八个SFR选择一个SFR作为可位寻址的SFR。
 122          
 123          如 地址为0x80的P0口，可以使用0x80至0x87作为其位寻址的物理地址，
 124          表示0x80这个地址单元中的第0位到第7位
 125          但这样一来就无法使用物理地址表示0x81到0x87这7个地址单元中的每一位了
 126          所以下一个能够位寻址的SFR就为地址单元是0x88的TCON
 127          
 128          
 129          
 130          可位寻址/不可位寻址：
 131          在单片机系统中，操作任意寄存器或者某一位的数据时，必须给出其物理地址，
 132          又因为一个寄存器里有8位，所以位的数量是寄存器数量的8倍，
 133          单片机无法对所有位进行编码，故每8个寄存器中，只有一个是可以位寻址的。
 134          对不可位寻址的寄存器，若要只操作其中一位而不影响其它位时，可用“&=”、
             -|=”、“^=”的方法进行位操作
 135          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    113    ----
   CONSTANT SIZE    =    190    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
